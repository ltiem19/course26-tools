<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphene Sublattice Formation</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 10px;
            background: #ffffff;
            color: #000000;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        h1 {
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            margin: 10px 0;
            text-align: center;
        }
        
        #canvas {
            border: 1px solid #ccc;
            background: #ffffff;
            margin: 10px 0;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
            justify-content: center;
            width: 100%;
            max-width: 600px;
        }
        
        button {
            background: #f0f0f0;
            color: #000;
            border: 1px solid #999;
            padding: 12px 16px;
            cursor: pointer;
            font-family: inherit;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            min-height: 44px;
            min-width: 44px;
            border-radius: 4px;
            touch-action: manipulation;
        }
        
        button:hover, button:focus {
            background: #e0e0e0;
            outline: none;
        }
        
        button:active {
            background: #d0d0d0;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            min-width: 200px;
        }
        
        .slider {
            width: 100%;
            height: 44px;
            -webkit-appearance: none;
            appearance: none;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #333;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #333;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .info {
            max-width: 95%;
            text-align: center;
            font-size: clamp(0.75rem, 2vw, 0.9rem);
            line-height: 1.4;
            margin: 10px 0;
            padding: 0 10px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin: 10px 0;
            justify-content: center;
            max-width: 95%;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: clamp(0.7rem, 2vw, 0.85rem);
        }
        
        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        @media (max-width: 600px) {
            .controls {
                flex-direction: column;
                gap: 8px;
            }
            
            button {
                width: 100%;
                max-width: 280px;
            }
            
            .slider-container {
                width: 100%;
                max-width: 280px;
            }
            
            .legend {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 500px) {
            body {
                padding: 5px;
            }
            
            h1 {
                font-size: 1rem;
                margin: 5px 0;
            }
            
            .info {
                margin: 5px 0;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <h1>Graphene Honeycomb Lattice Formation</h1>
    
    <div class="info">
        Graphene's honeycomb lattice forms from two interpenetrating triangular sublattices (A and B). 
        The B sublattice is displaced relative to A, creating the hexagonal symmetry where each carbon has three nearest neighbors.
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="color-dot" style="background: #ff4444;"></div>
            <span>A Sublattice (Red)</span>
        </div>
        <div class="legend-item">
            <div class="color-dot" style="background: #4444ff;"></div>
            <span>B Sublattice (Blue)</span>
        </div>
        <div class="legend-item">
            <div class="color-dot" style="background: #00ff00;"></div>
            <span>Honeycomb vectors A₁, A₂</span>
        </div>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button id="toggleModeBtn">Show Honeycomb</button>
        <div class="slider-container">
            <label>Overlay Progress</label>
            <input type="range" id="overlaySlider" class="slider" min="0" max="100" value="0">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        const overlaySlider = document.getElementById('overlaySlider');
        
        let showMode = 'separated'; // 'separated' or 'honeycomb'
        
        // Responsive canvas setup
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 800);
            const maxHeight = Math.min(window.innerHeight * 0.6, 600);
            const aspectRatio = 4/3;
            
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            render(parseInt(overlaySlider.value));
        }
        
        // Lattice parameters (scaled dynamically)
        function getLatticeParams() {
            const baseScale = Math.min(canvas.width, canvas.height) / 600;
            return {
                a: 40 * baseScale,
                centerX: canvas.width / 2,
                centerY: canvas.height / 2
            };
        }
        
        function generateTriangularLattice(offsetX, offsetY, range = 4) {
            const { a, centerX, centerY } = getLatticeParams();
            const a1 = { x: a * Math.sqrt(3)/2, y: a * 3/2 };
            const a2 = { x: a * Math.sqrt(3)/2, y: -a * 3/2 };
            
            const points = [];
            for (let i = -range; i <= range; i++) {
                for (let j = -range; j <= range; j++) {
                    const x = centerX + offsetX + i * a1.x + j * a2.x;
                    const y = centerY + offsetY + i * a1.y + j * a2.y;
                    
                    if (x > -50 && x < canvas.width + 50 && y > -50 && y < canvas.height + 50) {
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }
        
        function drawLattice(points, color, radius = 4) {
            const { a } = getLatticeParams();
            const scaledRadius = radius * Math.min(canvas.width, canvas.height) / 600;
            ctx.fillStyle = color;
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, scaledRadius, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function drawArrowhead(x, y, angle, color) {
            const size = 8 * Math.min(canvas.width, canvas.height) / 600;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - size * Math.cos(angle - Math.PI/6), y - size * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x - size * Math.cos(angle + Math.PI/6), y - size * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }
        
        function drawBonds(pointsA, pointsB, alpha = 1) {
            const { a } = getLatticeParams();
            ctx.strokeStyle = `rgba(100, 100, 100, ${alpha})`;
            ctx.lineWidth = Math.max(1, Math.min(canvas.width, canvas.height) / 800);
            
            pointsA.forEach(pointA => {
                pointsB.forEach(pointB => {
                    const dx = pointB.x - pointA.x;
                    const dy = pointB.y - pointA.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (Math.abs(dist - a) < a * 0.1) {
                        ctx.beginPath();
                        ctx.moveTo(pointA.x, pointA.y);
                        ctx.lineTo(pointB.x, pointB.y);
                        ctx.stroke();
                    }
                });
            });
        }
        
        function render(overlayProgress = 0) {
            const { a, centerX, centerY } = getLatticeParams();
            const delta1 = { x: a * Math.sqrt(3)/2, y: a/2 };
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (showMode === 'separated') {
                const separationX = (canvas.width * 0.3) * (1 - overlayProgress/100);
                
                const pointsA = generateTriangularLattice(-separationX, 0);
                const pointsB = generateTriangularLattice(separationX + delta1.x * overlayProgress/100, delta1.y * overlayProgress/100);
                
                if (overlayProgress > 70) {
                    const bondAlpha = (overlayProgress - 70) / 30;
                    drawBonds(pointsA, pointsB, bondAlpha);
                }
                
                drawLattice(pointsA, '#ff4444', 5);
                drawLattice(pointsB, '#4444ff', 5);
                
            } else {
                const pointsA = generateTriangularLattice(0, 0);
                const pointsB = generateTriangularLattice(delta1.x, delta1.y);
                
                drawBonds(pointsA, pointsB, 1);
                drawLattice(pointsA, '#ff4444', 5);
                drawLattice(pointsB, '#4444ff', 5);
                
                // Honeycomb lattice vectors
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = Math.max(2, Math.min(canvas.width, canvas.height) / 400);
                const honeycombA1 = { x: a * Math.sqrt(3), y: 0 };
                const honeycombA2 = { x: a * Math.sqrt(3)/2, y: a * 3/2 };
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + honeycombA1.x, centerY + honeycombA1.y);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + honeycombA2.x, centerY + honeycombA2.y);
                ctx.stroke();
                
                drawArrowhead(centerX + honeycombA1.x, centerY + honeycombA1.y, 0, '#00ff00');
                drawArrowhead(centerX + honeycombA2.x, centerY + honeycombA2.y, Math.PI/3, '#00ff00');
                
                ctx.fillStyle = '#00ff00';
                const fontSize = Math.max(12, Math.min(canvas.width, canvas.height) / 40);
                ctx.font = `${fontSize}px Courier New`;
                ctx.fillText('A₁', centerX + honeycombA1.x + 10, centerY + honeycombA1.y - 5);
                ctx.fillText('A₂', centerX + honeycombA2.x + 10, centerY + honeycombA2.y - 15);
            }
        }
        
        // Touch events for slider - simplified for Android compatibility
        overlaySlider.addEventListener('input', (e) => {
            const progress = parseInt(e.target.value);
            
            // Update mode based on slider position
            if (progress === 100 && showMode !== 'honeycomb') {
                showMode = 'honeycomb';
                toggleModeBtn.textContent = 'Show Separated';
            } else if (progress < 100 && showMode !== 'separated') {
                showMode = 'separated';
                toggleModeBtn.textContent = 'Show Honeycomb';
            }
            
            render(progress);
        });
        
        overlaySlider.addEventListener('change', (e) => {
            const progress = parseInt(e.target.value);
            
            // Update mode based on slider position
            if (progress === 100 && showMode !== 'honeycomb') {
                showMode = 'honeycomb';
                toggleModeBtn.textContent = 'Show Separated';
            } else if (progress < 100 && showMode !== 'separated') {
                showMode = 'separated';
                toggleModeBtn.textContent = 'Show Honeycomb';
            }
            
            render(progress);
        });
        
        // Handle touch specifically for slider
        overlaySlider.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        });
        
        overlaySlider.addEventListener('touchmove', (e) => {
            e.stopPropagation();
        });
        
        overlaySlider.addEventListener('touchend', (e) => {
            e.stopPropagation();
            // Force render after touch ends
            setTimeout(() => {
                const progress = parseInt(overlaySlider.value);
                
                // Update mode based on slider position
                if (progress === 100 && showMode !== 'honeycomb') {
                    showMode = 'honeycomb';
                    toggleModeBtn.textContent = 'Show Separated';
                } else if (progress < 100 && showMode !== 'separated') {
                    showMode = 'separated';
                    toggleModeBtn.textContent = 'Show Honeycomb';
                }
                
                render(progress);
            }, 10);
        });
        
        // Toggle mode button
        toggleModeBtn.addEventListener('click', () => {
            if (showMode === 'separated') {
                showMode = 'honeycomb';
                toggleModeBtn.textContent = 'Show Separated';
                overlaySlider.value = 100;
                render(100);
            } else {
                showMode = 'separated';
                toggleModeBtn.textContent = 'Show Honeycomb';
                overlaySlider.value = 0;
                render(0);
            }
        });
        
        // Handle orientation and resize
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });
        
        // Prevent zoom on double tap
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        });
        
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Initialize
        resizeCanvas();
    </script>
</body>
</html>