<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Structure Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
        }
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: #2a2a3e;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        h1 { 
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        .buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        button {
            padding: 0.5rem 1.5rem;
            border: none;
            border-radius: 0.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        button.active {
            background: #4a90e2;
            color: white;
        }
        button:not(.active) {
            background: #3a3a4e;
            color: #ccc;
        }
        button:not(.active):hover {
            background: #4a4a5e;
        }
        .info {
            background: #3a3a4e;
            padding: 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        canvas { display: block; }
        
        @media (max-width: 640px) {
            h1 { font-size: 1.2rem; }
            .buttons { flex-direction: column; }
            button { width: 100%; }
            .info { font-size: 0.75rem; }
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>Crystal Structure Visualizer</h1>
        <div class="buttons">
            <button id="btn-single" class="active">Single Crystalline</button>
            <button id="btn-poly">Polycrystalline</button>
            <button id="btn-amorphous">Amorphous</button>
        </div>
        <div class="info" id="info">
            <strong>Single Crystalline:</strong> Perfect long-range order. Atoms arranged in a periodic lattice extending macroscopic distances. This is what you get from Czochralski growth.
        </div>
    </div>
    <div id="canvas-container"></div>

    <script>
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color:white;padding:2rem;">Error: Three.js failed to load. Check your internet connection.</div>';
                return;
            }
            
        const infoTexts = {
            single: '<strong>Single Crystalline:</strong> Perfect long-range order. Atoms arranged in a periodic lattice extending macroscopic distances. This is what you get from Czochralski growth.',
            poly: '<strong>Polycrystalline:</strong> Multiple crystalline grains with different orientations. Notice the misalignment at grain boundaries - these interfaces disrupt long-range order and act as scattering centers, reducing mobility.',
            amorphous: '<strong>Amorphous:</strong> No long-range order, only short-range correlations. Random atomic positions. High scattering reduces mobility significantly (think of sputtered oxides).'
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        let atomsGroup = new THREE.Group();
        scene.add(atomsGroup);

        // Interaction
        let isRotating = true;
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            isRotating = false;
            previousPosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousPosition.x;
                const deltaY = e.clientY - previousPosition.y;
                atomsGroup.rotation.y += deltaX * 0.01;
                atomsGroup.rotation.x += deltaY * 0.01;
                previousPosition = { x: e.clientX, y: e.clientY };
            }
        });

        // Touch events
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            isRotating = false;
            previousPosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (isDragging) {
                const deltaX = e.touches[0].clientX - previousPosition.x;
                const deltaY = e.touches[0].clientY - previousPosition.y;
                atomsGroup.rotation.y += deltaX * 0.01;
                atomsGroup.rotation.x += deltaY * 0.01;
                previousPosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        // Structure builders
        function buildSingleCrystal() {
            const group = new THREE.Group();
            const atomMaterial = new THREE.MeshPhongMaterial({ color: 0x4a90e2, shininess: 100 });
            const bondMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            const latticeSize = 8;
            const spacing = 2.5;

            for (let x = -latticeSize/2; x < latticeSize/2; x++) {
                for (let y = -latticeSize/2; y < latticeSize/2; y++) {
                    for (let z = -latticeSize/2; z < latticeSize/2; z++) {
                        const atom = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), atomMaterial);
                        atom.position.set(x * spacing, y * spacing, z * spacing);
                        group.add(atom);

                        if (x < latticeSize/2 - 1) {
                            const points = [
                                new THREE.Vector3(x * spacing, y * spacing, z * spacing),
                                new THREE.Vector3((x + 1) * spacing, y * spacing, z * spacing)
                            ];
                            const bond = new THREE.Line(
                                new THREE.BufferGeometry().setFromPoints(points),
                                bondMaterial
                            );
                            group.add(bond);
                        }
                    }
                }
            }
            return group;
        }

        function buildPolycrystal() {
            const group = new THREE.Group();
            const atomMaterial = new THREE.MeshPhongMaterial({ color: 0x4a90e2, shininess: 100 });
            const bondMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });

            const grains = [
                { center: [-7, -7, 0], size: 3.5, rotation: 0 },
                { center: [7, -7, 0], size: 3.5, rotation: Math.PI / 6 },
                { center: [-7, 7, 0], size: 3.5, rotation: -Math.PI / 5 },
                { center: [7, 7, 0], size: 3.5, rotation: Math.PI / 4 },
                { center: [0, -7, 0], size: 3.5, rotation: Math.PI / 8 },
                { center: [0, 7, 0], size: 3.5, rotation: -Math.PI / 7 },
                { center: [-7, 0, 0], size: 3.5, rotation: Math.PI / 10 },
                { center: [7, 0, 0], size: 3.5, rotation: -Math.PI / 9 },
                { center: [0, 0, 0], size: 3.5, rotation: Math.PI / 12 }
            ];

            grains.forEach(grain => {
                for (let x = -grain.size/2; x < grain.size/2; x++) {
                    for (let y = -grain.size/2; y < grain.size/2; y++) {
                        for (let z = -1; z <= 1; z++) {
                            const localX = x * 2;
                            const localY = y * 2;
                            const rotatedX = localX * Math.cos(grain.rotation) - localY * Math.sin(grain.rotation);
                            const rotatedY = localX * Math.sin(grain.rotation) + localY * Math.cos(grain.rotation);

                            const atom = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), atomMaterial);
                            atom.position.set(
                                grain.center[0] + rotatedX,
                                grain.center[1] + rotatedY,
                                grain.center[2] + z * 2
                            );
                            group.add(atom);

                            if (x < grain.size/2 - 1) {
                                const localX2 = (x + 1) * 2;
                                const localY2 = y * 2;
                                const rotatedX2 = localX2 * Math.cos(grain.rotation) - localY2 * Math.sin(grain.rotation);
                                const rotatedY2 = localX2 * Math.sin(grain.rotation) + localY2 * Math.cos(grain.rotation);

                                const points = [
                                    new THREE.Vector3(grain.center[0] + rotatedX, grain.center[1] + rotatedY, grain.center[2] + z * 2),
                                    new THREE.Vector3(grain.center[0] + rotatedX2, grain.center[1] + rotatedY2, grain.center[2] + z * 2)
                                ];
                                const bond = new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints(points),
                                    bondMaterial
                                );
                                group.add(bond);
                            }
                        }
                    }
                }
            });
            return group;
        }

        function buildAmorphous() {
            const group = new THREE.Group();
            const atomMaterial = new THREE.MeshPhongMaterial({ color: 0x4a90e2, shininess: 100 });
            const bondMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            const numAtoms = 300;
            const spread = 15;
            const positions = [];

            for (let i = 0; i < numAtoms; i++) {
                const x = (Math.random() - 0.5) * spread;
                const y = (Math.random() - 0.5) * spread;
                const z = (Math.random() - 0.5) * spread;

                const atom = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), atomMaterial);
                atom.position.set(x, y, z);
                group.add(atom);
                positions.push(new THREE.Vector3(x, y, z));
            }

            for (let i = 0; i < positions.length; i++) {
                let bondCount = 0;
                for (let j = i + 1; j < positions.length && bondCount < 3; j++) {
                    if (positions[i].distanceTo(positions[j]) < 2) {
                        const bond = new THREE.Line(
                            new THREE.BufferGeometry().setFromPoints([positions[i], positions[j]]),
                            bondMaterial
                        );
                        group.add(bond);
                        bondCount++;
                    }
                }
            }
            return group;
        }

        function setStructure(type) {
            scene.remove(atomsGroup);
            
            if (type === 'single') {
                atomsGroup = buildSingleCrystal();
            } else if (type === 'poly') {
                atomsGroup = buildPolycrystal();
            } else {
                atomsGroup = buildAmorphous();
            }
            
            scene.add(atomsGroup);
            document.getElementById('info').innerHTML = infoTexts[type];
            
            // Update button states
            document.querySelectorAll('.buttons button').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + type).classList.add('active');
        }

        // Button handlers
        document.getElementById('btn-single').addEventListener('click', () => setStructure('single'));
        document.getElementById('btn-poly').addEventListener('click', () => setStructure('poly'));
        document.getElementById('btn-amorphous').addEventListener('click', () => setStructure('amorphous'));

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (isRotating) {
                atomsGroup.rotation.y += 0.005;
                atomsGroup.rotation.x += 0.002;
            }
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        setStructure('single');
        animate();
        }); // End of window.onload
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Structure Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #root { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const THREE = window.THREE;

        const CrystalStructureVisualizer = () => {
          const mountRef = useRef(null);
          const [structureType, setStructureType] = useState('single');
          const [rotating, setRotating] = useState(true);
          const sceneRef = useRef(null);
          const cameraRef = useRef(null);
          const rendererRef = useRef(null);
          const atomsGroupRef = useRef(null);

          useEffect(() => {
            if (!mountRef.current) return;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            sceneRef.current = scene;

            const camera = new THREE.PerspectiveCamera(
              75,
              mountRef.current.clientWidth / mountRef.current.clientHeight,
              0.1,
              1000
            );
            camera.position.z = 25;
            cameraRef.current = camera;

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
            mountRef.current.appendChild(renderer.domElement);
            rendererRef.current = renderer;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            let isDragging = false;
            let previousPosition = { x: 0, y: 0 };

            const onPointerDown = (e) => {
              isDragging = true;
              setRotating(false);
              const pos = e.touches ? e.touches[0] : e;
              previousPosition = { x: pos.clientX, y: pos.clientY };
            };

            const onPointerUp = () => {
              isDragging = false;
            };

            const onPointerMove = (e) => {
              if (isDragging && atomsGroupRef.current) {
                const pos = e.touches ? e.touches[0] : e;
                const deltaX = pos.clientX - previousPosition.x;
                const deltaY = pos.clientY - previousPosition.y;
                
                atomsGroupRef.current.rotation.y += deltaX * 0.01;
                atomsGroupRef.current.rotation.x += deltaY * 0.01;
                
                previousPosition = { x: pos.clientX, y: pos.clientY };
              }
            };

            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('touchstart', onPointerDown);
            renderer.domElement.addEventListener('touchend', onPointerUp);
            renderer.domElement.addEventListener('touchmove', onPointerMove);

            const animate = () => {
              requestAnimationFrame(animate);
              if (rotating && atomsGroupRef.current) {
                atomsGroupRef.current.rotation.y += 0.005;
                atomsGroupRef.current.rotation.x += 0.002;
              }
              renderer.render(scene, camera);
            };
            animate();

            const handleResize = () => {
              if (!mountRef.current) return;
              camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
            };
            window.addEventListener('resize', handleResize);

            return () => {
              window.removeEventListener('resize', handleResize);
              renderer.domElement.removeEventListener('mousedown', onPointerDown);
              renderer.domElement.removeEventListener('mouseup', onPointerUp);
              renderer.domElement.removeEventListener('mousemove', onPointerMove);
              renderer.domElement.removeEventListener('touchstart', onPointerDown);
              renderer.domElement.removeEventListener('touchend', onPointerUp);
              renderer.domElement.removeEventListener('touchmove', onPointerMove);
              mountRef.current?.removeChild(renderer.domElement);
            };
          }, [rotating]);

          useEffect(() => {
            if (!sceneRef.current) return;

            if (atomsGroupRef.current) {
              sceneRef.current.remove(atomsGroupRef.current);
            }

            const atomsGroup = new THREE.Group();
            atomsGroupRef.current = atomsGroup;

            const atomMaterial = new THREE.MeshPhongMaterial({ 
              color: 0x4a90e2,
              shininess: 100 
            });
            const bondMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });

            if (structureType === 'single') {
              const latticeSize = 8;
              const spacing = 2.5;
              
              for (let x = -latticeSize/2; x < latticeSize/2; x++) {
                for (let y = -latticeSize/2; y < latticeSize/2; y++) {
                  for (let z = -latticeSize/2; z < latticeSize/2; z++) {
                    const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const atom = new THREE.Mesh(geometry, atomMaterial);
                    atom.position.set(x * spacing, y * spacing, z * spacing);
                    atomsGroup.add(atom);

                    if (x < latticeSize/2 - 1) {
                      const points = [];
                      points.push(new THREE.Vector3(x * spacing, y * spacing, z * spacing));
                      points.push(new THREE.Vector3((x + 1) * spacing, y * spacing, z * spacing));
                      const bondGeometry = new THREE.BufferGeometry().setFromPoints(points);
                      const bond = new THREE.Line(bondGeometry, bondMaterial);
                      atomsGroup.add(bond);
                    }
                  }
                }
              }
            } else if (structureType === 'poly') {
              const grains = [
                { center: [-7, -7, 0], size: 3.5, rotation: 0 },
                { center: [7, -7, 0], size: 3.5, rotation: Math.PI / 6 },
                { center: [-7, 7, 0], size: 3.5, rotation: -Math.PI / 5 },
                { center: [7, 7, 0], size: 3.5, rotation: Math.PI / 4 },
                { center: [0, -7, 0], size: 3.5, rotation: Math.PI / 8 },
                { center: [0, 7, 0], size: 3.5, rotation: -Math.PI / 7 },
                { center: [-7, 0, 0], size: 3.5, rotation: Math.PI / 10 },
                { center: [7, 0, 0], size: 3.5, rotation: -Math.PI / 9 },
                { center: [0, 0, 0], size: 3.5, rotation: Math.PI / 12 },
              ];

              grains.forEach((grain) => {
                for (let x = -grain.size/2; x < grain.size/2; x++) {
                  for (let y = -grain.size/2; y < grain.size/2; y++) {
                    for (let z = -1; z <= 1; z++) {
                      const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                      const atom = new THREE.Mesh(geometry, atomMaterial);
                      
                      const localX = x * 2;
                      const localY = y * 2;
                      const rotatedX = localX * Math.cos(grain.rotation) - localY * Math.sin(grain.rotation);
                      const rotatedY = localX * Math.sin(grain.rotation) + localY * Math.cos(grain.rotation);
                      
                      atom.position.set(
                        grain.center[0] + rotatedX,
                        grain.center[1] + rotatedY,
                        grain.center[2] + z * 2
                      );
                      atomsGroup.add(atom);

                      if (x < grain.size/2 - 1) {
                        const localX2 = (x + 1) * 2;
                        const localY2 = y * 2;
                        const rotatedX2 = localX2 * Math.cos(grain.rotation) - localY2 * Math.sin(grain.rotation);
                        const rotatedY2 = localX2 * Math.sin(grain.rotation) + localY2 * Math.cos(grain.rotation);
                        
                        const points = [
                          new THREE.Vector3(grain.center[0] + rotatedX, grain.center[1] + rotatedY, grain.center[2] + z * 2),
                          new THREE.Vector3(grain.center[0] + rotatedX2, grain.center[1] + rotatedY2, grain.center[2] + z * 2)
                        ];
                        const bondGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const bond = new THREE.Line(bondGeometry, bondMaterial);
                        atomsGroup.add(bond);
                      }
                    }
                  }
                }
              });
            } else if (structureType === 'amorphous') {
              const numAtoms = 300;
              const spread = 15;
              
              const positions = [];
              for (let i = 0; i < numAtoms; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const atom = new THREE.Mesh(geometry, atomMaterial);
                
                const x = (Math.random() - 0.5) * spread;
                const y = (Math.random() - 0.5) * spread;
                const z = (Math.random() - 0.5) * spread;
                
                atom.position.set(x, y, z);
                atomsGroup.add(atom);
                positions.push(new THREE.Vector3(x, y, z));
              }

              for (let i = 0; i < positions.length; i++) {
                let bondCount = 0;
                for (let j = i + 1; j < positions.length && bondCount < 3; j++) {
                  const distance = positions[i].distanceTo(positions[j]);
                  if (distance < 2) {
                    const points = [positions[i], positions[j]];
                    const bondGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const bond = new THREE.Line(bondGeometry, bondMaterial);
                    atomsGroup.add(bond);
                    bondCount++;
                  }
                }
              }
            }

            sceneRef.current.add(atomsGroup);
          }, [structureType]);

          return (
            <div className="w-full h-screen flex flex-col bg-gray-900">
              <div className="bg-gray-800 p-3 md:p-4 shadow-lg">
                <h1 className="text-xl md:text-2xl font-bold text-white mb-3 md:mb-4">Crystal Structure Visualizer</h1>
                
                <div className="flex flex-col sm:flex-row gap-2 md:gap-4 mb-3 md:mb-4">
                  <button
                    onClick={() => setStructureType('single')}
                    className={`px-4 md:px-6 py-2 rounded font-semibold transition text-sm md:text-base ${
                      structureType === 'single'
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                    }`}
                  >
                    Single Crystalline
                  </button>
                  <button
                    onClick={() => setStructureType('poly')}
                    className={`px-4 md:px-6 py-2 rounded font-semibold transition text-sm md:text-base ${
                      structureType === 'poly'
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                    }`}
                  >
                    Polycrystalline
                  </button>
                  <button
                    onClick={() => setStructureType('amorphous')}
                    className={`px-4 md:px-6 py-2 rounded font-semibold transition text-sm md:text-base ${
                      structureType === 'amorphous'
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                    }`}
                  >
                    Amorphous
                  </button>
                </div>

                <div className="mt-3 md:mt-4 p-2 md:p-3 bg-gray-700 rounded text-white text-xs md:text-sm">
                  {structureType === 'single' && (
                    <div>
                      <strong>Single Crystalline:</strong> Perfect long-range order. Atoms arranged in a periodic lattice extending macroscopic distances. This is what you get from Czochralski growth.
                    </div>
                  )}
                  {structureType === 'poly' && (
                    <div>
                      <strong>Polycrystalline:</strong> Multiple crystalline grains with different orientations. Notice the misalignment at grain boundaries - these interfaces disrupt long-range order and act as scattering centers, reducing mobility.
                    </div>
                  )}
                  {structureType === 'amorphous' && (
                    <div>
                      <strong>Amorphous:</strong> No long-range order, only short-range correlations. Random atomic positions. High scattering reduces mobility significantly (think of sputtered oxides).
                    </div>
                  )}
                </div>
              </div>

              <div ref={mountRef} className="flex-1" />
            </div>
          );
        };

        ReactDOM.render(<CrystalStructureVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>