<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fermi Sphere Thermal Effect</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #ffffff;
            color: #000000;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
            width: 100%;
        }
        .controls {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
        }
        .sphere-box {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            text-align: center;
        }
        canvas {
            border: 2px solid #999;
            background: #fff;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        .slider-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }
        label {
            font-size: 16px;
            font-weight: bold;
            white-space: nowrap;
        }
        input[type="range"] {
            flex: 1;
            height: 12px;
            min-height: 44px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #4444aa;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #4444aa;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: #ddd;
            border-radius: 4px;
        }
        input[type="range"]::-moz-range-track {
            height: 8px;
            background: #ddd;
            border-radius: 4px;
        }
        input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }
        .value {
            font-family: monospace;
            color: #000000;
            font-size: 18px;
            min-width: 80px;
        }
        .legend {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
            text-align: left;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #999;
            flex-shrink: 0;
        }
        .blue-box {
            background: #4444aa;
        }
        .gray-box {
            background: #d0d0d0;
        }
        @media (max-width: 500px) {
            body {
                padding: 5px;
            }
            .controls, .sphere-box {
                padding: 10px;
            }
            label {
                font-size: 14px;
            }
            .value {
                font-size: 16px;
                min-width: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="slider-group">
                <div class="slider-row">
                    <label>Temperature:</label>
                    <input type="range" id="temperature" min="0" max="1000" step="20" value="0">
                    <span class="value" id="tempValue">0 K</span>
                </div>
            </div>
            <div class="slider-group">
                <label>
                    <input type="checkbox" id="quantize">
                    Quantize
                </label>
            </div>
        </div>

        <div class="sphere-box">
            <canvas id="sphereCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color blue-box"></div>
                    <span>Blue = Occupied states</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color gray-box"></div>
                    <span>Gray = Vacant states</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SimpleFermiSphere {
            constructor() {
                this.canvas = document.getElementById('sphereCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.temperature = 0;
                this.quantized = false;
                this.EF = 5.0; // Fermi energy in eV
                this.vF = 0.023; // Further reduced for ~40 meV level spacing
                
                this.setupCanvas();
                this.setupEventListeners();
                this.draw();
            }
            
            setupCanvas() {
                const container = this.canvas.parentElement;
                const containerWidth = Math.max(Math.min(container.clientWidth - 30, 400), 200);
                const aspectRatio = 620 / 400;
                
                this.canvas.width = containerWidth;
                this.canvas.height = containerWidth * aspectRatio;
                this.scale = containerWidth / 400;
                this.kF = 140 * this.scale;
            }
            
            setupEventListeners() {
                document.getElementById('temperature').addEventListener('input', (e) => {
                    this.temperature = parseInt(e.target.value);
                    document.getElementById('tempValue').textContent = this.temperature + ' K';
                    this.draw();
                });
                
                document.getElementById('quantize').addEventListener('change', (e) => {
                    this.quantized = e.target.checked;
                    this.draw();
                });
                
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.draw();
                });
            }
            
            draw() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                const centerX = canvas.width / 2;
                const centerY = 180 * this.scale;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw coordinate axes
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1 * this.scale;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, 350 * this.scale);
                ctx.stroke();
                
                // Axis labels
                ctx.fillStyle = '#000000';
                ctx.font = `${16 * this.scale}px Courier New`;
                ctx.fillText('kx', canvas.width - 25 * this.scale, centerY - 10 * this.scale);
                ctx.fillText('ky', centerX + 10 * this.scale, 20 * this.scale);
                
                // Calculate thermal width (exaggerated for visibility)
                const kBT = this.temperature * 8.617e-5;
                const thermalWidth = this.kF * (kBT / this.EF) * 50; // Exaggerate by 50x
                
                if (this.quantized) {
                    this.drawQuantized(centerX, centerY, kBT, thermalWidth);
                } else {
                    this.drawContinuous(centerX, centerY, kBT, thermalWidth);
                }
                
                // Draw histogram underneath
                this.drawHistogram(thermalWidth);
            }
            
            drawContinuous(centerX, centerY, kBT, thermalWidth) {
                const ctx = this.ctx;
                
                // Draw large gray circle for empty states
                const maxRadius = this.kF + 60 * this.scale;
                ctx.fillStyle = '#d0d0d0';
                ctx.beginPath();
                ctx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw blue filled sphere (occupied states at T=0)
                ctx.fillStyle = '#4444aa';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.kF, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw thermal excitation particles - stay close to Fermi surface
                if (this.temperature > 0) {
                    const numParticles = Math.min(Math.floor(this.temperature / 5), 500);
                    const maxSpread = Math.min(thermalWidth * 1.5, 40 * this.scale); // Limit spread near EF
                    
                    // Blue circles in gray region (thermally excited electrons)
                    ctx.fillStyle = '#4444aa';
                    for (let i = 0; i < numParticles; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        // Gaussian-like distribution near Fermi surface
                        const spread = (Math.random() + Math.random() - 1) * maxSpread;
                        const r = this.kF + Math.abs(spread);
                        if (r <= maxRadius) {
                            const x = centerX + r * Math.cos(angle);
                            const y = centerY + r * Math.sin(angle);
                            ctx.beginPath();
                            ctx.arc(x, y, 1.5 * this.scale, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                    
                    // Gray circles in blue region (holes)
                    ctx.fillStyle = '#d0d0d0';
                    for (let i = 0; i < numParticles; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const spread = (Math.random() + Math.random() - 1) * maxSpread;
                        const r = this.kF - Math.abs(spread);
                        if (r >= 0) {
                            const x = centerX + r * Math.cos(angle);
                            const y = centerY + r * Math.sin(angle);
                            ctx.beginPath();
                            ctx.arc(x, y, 1.5 * this.scale, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                }
                
                // Draw black dashed Fermi surface
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2 * this.scale;
                ctx.setLineDash([5 * this.scale, 5 * this.scale]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.kF, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            drawQuantized(centerX, centerY, kBT, thermalWidth) {
                const ctx = this.ctx;
                const spacing = 50 * this.scale;
                const radii = [this.kF - spacing, this.kF, this.kF + spacing];
                
                const getOccupation = (k) => {
                    if (this.temperature === 0) {
                        return k <= this.kF ? 1 : 0;
                    }
                    const deltaE = this.vF * (k - this.kF) * (this.EF / this.kF);
                    return 1 / (1 + Math.exp(deltaE / Math.max(kBT, 1e-6)));
                };
                
                radii.forEach((r, i) => {
                    const occupation = getOccupation(r);
                    
                    // Innermost and middle ring: blue (occupied states)
                    if (i < 2) {
                        ctx.strokeStyle = '#4444aa';
                        ctx.lineWidth = 8 * this.scale;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Add gray particles if T > 0 (holes) - more and smaller
                        if (this.temperature > 0 && occupation < 0.95) {
                            const numHoles = Math.floor((1 - occupation) * 40);
                            ctx.fillStyle = '#d0d0d0';
                            for (let j = 0; j < numHoles; j++) {
                                const angle = (j / numHoles) * 2 * Math.PI + Math.random() * 0.5;
                                const x = centerX + r * Math.cos(angle);
                                const y = centerY + r * Math.sin(angle);
                                ctx.beginPath();
                                ctx.arc(x, y, 1.5 * this.scale, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                    } else {
                        // Outer ring: gray (empty states)
                        ctx.strokeStyle = '#d0d0d0';
                        ctx.lineWidth = 8 * this.scale;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Add blue particles if T > 0 (thermally excited electrons)
                        if (this.temperature > 0 && occupation > 0.02) {
                            const numElectrons = Math.floor(occupation * 40);
                            ctx.fillStyle = '#4444aa';
                            for (let j = 0; j < numElectrons; j++) {
                                const angle = (j / numElectrons) * 2 * Math.PI + Math.random() * 0.5;
                                const x = centerX + r * Math.cos(angle);
                                const y = centerY + r * Math.sin(angle);
                                ctx.beginPath();
                                ctx.arc(x, y, 1.5 * this.scale, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                    }
                    
                    // Draw black outline on middle ring (Fermi level)
                    if (i === 1) {
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2 * this.scale;
                        ctx.setLineDash([5 * this.scale, 5 * this.scale]);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                });
            }
            
            drawHistogram(thermalWidth) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // Histogram area - shifted further down
                const histY = 480 * this.scale;
                const histHeight = 120 * this.scale;
                const histWidth = 300 * this.scale;
                const histX = (canvas.width - histWidth) / 2;
                
                // Draw histogram axes
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1 * this.scale;
                ctx.beginPath();
                ctx.moveTo(histX, histY);
                ctx.lineTo(histX + histWidth, histY);
                ctx.moveTo(histX, histY);
                ctx.lineTo(histX, histY - histHeight);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#000000';
                ctx.font = `${12 * this.scale}px Courier New`;
                ctx.fillText('|k|', histX + histWidth + 10 * this.scale, histY + 5 * this.scale);
                ctx.save();
                ctx.translate(histX - 40 * this.scale, histY - histHeight/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('occupation', 0, 0);
                ctx.restore();
                
                if (this.quantized) {
                    // Draw discrete peaks
                    const spacing = 50 * this.scale;
                    const kValues = [this.kF - spacing, this.kF, this.kF + spacing];
                    
                    const getOccupation = (k) => {
                        if (this.temperature === 0) {
                            return k <= this.kF ? 1 : 0;
                        }
                        const deltaE = this.vF * (k - this.kF) * (this.EF / this.kF);
                        const kBT = this.temperature * 8.617e-5;
                        return 1 / (1 + Math.exp(deltaE / Math.max(kBT, 1e-6)));
                    };
                    
                    kValues.forEach((k, i) => {
                        const xPos = histX + histWidth/2 + (k - this.kF) * 1.2;
                        const occupation = getOccupation(k);
                        const height = histHeight * 0.8 * occupation;
                        const barWidth = 15 * this.scale;
                        
                        ctx.fillStyle = '#4444aa';
                        ctx.fillRect(xPos - barWidth/2, histY - height, barWidth, height);
                    });
                } else {
                    // Continuous distribution with Fermi-Dirac
                    const kFPos = histWidth / 2;
                    const numBins = 100;
                    const binWidth = histWidth / numBins;
                    const kBT = this.temperature * 8.617e-5;
                    
                    for (let i = 0; i < numBins; i++) {
                        const binCenter = (i / numBins - 0.5) * histWidth;
                        
                        let height = 0;
                        
                        if (this.temperature === 0) {
                            // Step function at kF
                            if (binCenter < 0) {
                                height = histHeight * 0.8;
                            }
                        } else {
                            // Proper Fermi-Dirac distribution
                            const k = this.kF + binCenter * (this.kF / (histWidth/2));
                            const deltaE = this.vF * (k - this.kF) * (this.EF / this.kF);
                            const occupation = 1 / (1 + Math.exp(deltaE / Math.max(kBT, 1e-6)));
                            height = histHeight * 0.8 * occupation;
                        }
                        
                        ctx.fillStyle = '#4444aa';
                        ctx.fillRect(histX + i * binWidth, histY - height, binWidth - 1, height);
                    }
                }
            }
        }
        
        window.addEventListener('load', () => {
            new SimpleFermiSphere();
        });
    </script>
</body>
</html>