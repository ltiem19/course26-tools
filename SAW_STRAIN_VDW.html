<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rayleigh Surface Acoustic Wave Visualization</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const SAWVisualization = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [showStrain, setShowStrain] = useState(false);
            const [showField, setShowField] = useState(false);
            const [showVdWLayer, setShowVdWLayer] = useState(false);
            const [sawActive, setSawActive] = useState(false);
            const timeRef = useRef(0);
            const animationRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const amplitude = 1.8;
                const wavelengthMultiplier = 2.2;
                
                const updateCanvasSize = () => {
                    const rect = container.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                };
                
                updateCanvasSize();
                window.addEventListener('resize', updateCanvasSize);
                
                const ctx = canvas.getContext('2d');
                
                const animate = () => {
                    if (sawActive) {
                        timeRef.current += 1;
                    }
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    const baseSpacing = Math.min(width, height) / 35;
                    const nX = Math.floor(width / baseSpacing) - 2;
                    const nY = Math.floor(height / baseSpacing * 0.6);
                    const spacingX = width / (nX + 2);
                    const spacingY = height / (nY + 5);
                    
                    const wavelength = 8 * spacingX * wavelengthMultiplier;
                    const k = (2 * Math.PI) / wavelength;
                    const omega = 0.05;
                    
                    const t = timeRef.current;
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, '#f8f9fa');
                    gradient.addColorStop(1, '#e9ecef');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                    
                    const surfaceY = height * 0.4;
                    
                    // Draw electric field if enabled
                    if (showField) {
                        const fieldSamples = Math.floor(width / (spacingX * 0.5));
                        const vacuumExtent = wavelength / (2 * Math.PI) * 3.0; // Much larger rendering above surface
                        const vacuumDecayLength = wavelength / (2 * Math.PI) * 0.5; // Decay length in vacuum
                        const penetrationDepth = wavelength * 0.35; // Fast decay in bulk (exaggerated)
                        const bulkDepth = spacingY * nY;
                        
                        for (let sample = 0; sample < fieldSamples; sample++) {
                            const x = (sample / fieldSamples) * width;
                            const phase = k * x - omega * t;
                            const surfaceStrain = sawActive ? amplitude * Math.cos(phase) : 0;
                            
                            // Start from well above surface, end deep in bulk
                            const totalHeight = vacuumExtent + bulkDepth;
                            const fieldGradient = ctx.createLinearGradient(
                                x, surfaceY - vacuumExtent,
                                x, surfaceY + bulkDepth
                            );
                            
                            const totalStops = 50;
                            for (let i = 0; i <= totalStops; i++) {
                                const gradientPos = i / totalStops;
                                const yPos = surfaceY - vacuumExtent + gradientPos * totalHeight;
                                const depthFromSurface = yPos - surfaceY;
                                
                                let decayFactor;
                                if (depthFromSurface < 0) {
                                    // Vacuum side: evanescent decay upward from surface
                                    decayFactor = Math.exp(depthFromSurface / vacuumDecayLength);
                                } else {
                                    // Bulk side: fast exponential decay downward
                                    decayFactor = Math.exp(-depthFromSurface / penetrationDepth);
                                }
                                
                                // Ensure intensity goes to zero
                                const intensity = Math.max(0, Math.abs(surfaceStrain) * decayFactor * 0.75);
                                
                                if (surfaceStrain > 0) {
                                    fieldGradient.addColorStop(gradientPos, `rgba(255, 200, 80, ${intensity})`);
                                } else {
                                    fieldGradient.addColorStop(gradientPos, `rgba(80, 200, 255, ${intensity})`);
                                }
                            }
                            
                            ctx.fillStyle = fieldGradient;
                            const barWidth = width / fieldSamples + 1;
                            ctx.fillRect(x, surfaceY - vacuumExtent, barWidth, totalHeight);
                        }
                    }
                    
                    // Calculate all atom positions first
                    const atoms = [];
                    for (let iy = 0; iy < nY; iy++) {
                        atoms[iy] = [];
                        for (let ix = 0; ix < nX; ix++) {
                            const x0 = spacingX * (ix + 1);
                            const y0 = surfaceY + spacingY * (iy + 1);
                            
                            const depth = iy * spacingY;
                            const penetrationDepth = wavelength;
                            const decayFactor = Math.exp(-depth / penetrationDepth);
                            
                            const phase = k * x0 - omega * t;
                            
                            // Rayleigh wave: retrograde elliptical motion
                            const ux = sawActive ? amplitude * spacingX * 0.25 * decayFactor * Math.sin(phase) : 0;
                            const uy = sawActive ? -amplitude * spacingY * 0.35 * decayFactor * Math.cos(phase) : 0;
                            
                            const x = x0 + ux;
                            const y = y0 + uy;
                            
                            atoms[iy][ix] = { x, y, x0, y0, phase, decayFactor };
                        }
                    }
                    
                    // Draw lattice connections
                    ctx.lineWidth = 1;
                    
                    // Horizontal connections
                    for (let iy = 0; iy < nY; iy++) {
                        for (let ix = 0; ix < nX - 1; ix++) {
                            const atom1 = atoms[iy][ix];
                            const atom2 = atoms[iy][ix + 1];
                            
                            if (showStrain && sawActive) {
                                const dx = atom2.x - atom1.x;
                                const restDx = spacingX;
                                const strain = (dx - restDx) / restDx;
                                
                                const strainIntensity = Math.min(Math.abs(strain) * 3, 1);
                                if (strain > 0) {
                                    ctx.strokeStyle = `rgba(255, 80, 80, ${0.3 + 0.4 * strainIntensity})`;
                                } else {
                                    ctx.strokeStyle = `rgba(80, 120, 255, ${0.3 + 0.4 * strainIntensity})`;
                                }
                            } else {
                                ctx.strokeStyle = 'rgba(150, 150, 160, 0.3)';
                            }
                            
                            ctx.beginPath();
                            ctx.moveTo(atom1.x, atom1.y);
                            ctx.lineTo(atom2.x, atom2.y);
                            ctx.stroke();
                        }
                    }
                    
                    // Vertical connections
                    for (let iy = 0; iy < nY - 1; iy++) {
                        for (let ix = 0; ix < nX; ix++) {
                            const atom1 = atoms[iy][ix];
                            const atom2 = atoms[iy + 1][ix];
                            
                            ctx.strokeStyle = 'rgba(150, 150, 160, 0.2)';
                            ctx.beginPath();
                            ctx.moveTo(atom1.x, atom1.y);
                            ctx.lineTo(atom2.x, atom2.y);
                            ctx.stroke();
                        }
                    }
                    
                    // Draw vdW layer if enabled
                    if (showVdWLayer) {
                        const layerWidth = width * 0.6;
                        const layerStartX = width * 0.2;
                        const layerSamples = Math.floor(nX * 2.4);
                        const layerThickness = spacingY * 0.15;
                        const vdWGap = spacingY * 0.3;
                        
                        if (showStrain && sawActive) {
                            const segments = 100;
                            for (let seg = 0; seg < segments; seg++) {
                                const segStartRatio = seg / segments;
                                const segEndRatio = (seg + 1) / segments;
                                
                                const xCenter = layerStartX + (segStartRatio + segEndRatio) / 2 * layerWidth;
                                const phase = k * xCenter - omega * t;
                                const strain = amplitude * Math.cos(phase);
                                
                                ctx.beginPath();
                                
                                for (let i = 0; i <= 2; i++) {
                                    const ratio = segStartRatio + i * (segEndRatio - segStartRatio) / 2;
                                    const x = layerStartX + ratio * layerWidth;
                                    const localPhase = k * x - omega * t;
                                    const surfaceDisplacement = sawActive ? -amplitude * spacingY * 0.35 * Math.cos(localPhase) : 0;
                                    const y = surfaceY + surfaceDisplacement - vdWGap;
                                    
                                    if (i === 0) {
                                        ctx.moveTo(x, y);
                                    } else {
                                        ctx.lineTo(x, y);
                                    }
                                }
                                
                                for (let i = 2; i >= 0; i--) {
                                    const ratio = segStartRatio + i * (segEndRatio - segStartRatio) / 2;
                                    const x = layerStartX + ratio * layerWidth;
                                    const localPhase = k * x - omega * t;
                                    const surfaceDisplacement = sawActive ? -amplitude * spacingY * 0.35 * Math.cos(localPhase) : 0;
                                    const y = surfaceY + surfaceDisplacement - vdWGap - layerThickness;
                                    ctx.lineTo(x, y);
                                }
                                
                                ctx.closePath();
                                
                                let baseColor;
                                if (strain > 0) {
                                    const intensity = Math.min(0.4, strain * 0.8);
                                    baseColor = {
                                        r: 160 + Math.floor(95 * intensity),
                                        g: 160 - Math.floor(50 * intensity),
                                        b: 165 - Math.floor(60 * intensity)
                                    };
                                } else {
                                    const intensity = Math.min(0.4, -strain * 0.8);
                                    baseColor = {
                                        r: 160 - Math.floor(50 * intensity),
                                        g: 160 - Math.floor(20 * intensity),
                                        b: 165 + Math.floor(90 * intensity)
                                    };
                                }
                                
                                ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0.75)`;
                                ctx.fill();
                            }
                            
                            ctx.strokeStyle = 'rgba(80, 80, 90, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            for (let i = 0; i <= layerSamples; i++) {
                                const x = layerStartX + (i / layerSamples) * layerWidth;
                                const phase = k * x - omega * t;
                                const surfaceDisplacement = sawActive ? -amplitude * spacingY * 0.35 * Math.cos(phase) : 0;
                                const y = surfaceY + surfaceDisplacement - vdWGap;
                                
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            ctx.stroke();
                        } else {
                            ctx.beginPath();
                            
                            for (let i = 0; i <= layerSamples; i++) {
                                const x = layerStartX + (i / layerSamples) * layerWidth;
                                const phase = k * x - omega * t;
                                const surfaceDisplacement = sawActive ? -amplitude * spacingY * 0.35 * Math.cos(phase) : 0;
                                const y = surfaceY + surfaceDisplacement - vdWGap;
                                
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            
                            for (let i = layerSamples; i >= 0; i--) {
                                const x = layerStartX + (i / layerSamples) * layerWidth;
                                const phase = k * x - omega * t;
                                const surfaceDisplacement = sawActive ? -amplitude * spacingY * 0.35 * Math.cos(phase) : 0;
                                const y = surfaceY + surfaceDisplacement - vdWGap - layerThickness;
                                ctx.lineTo(x, y);
                            }
                            
                            ctx.closePath();
                            
                            const layerGradient = ctx.createLinearGradient(0, surfaceY - vdWGap - layerThickness, 0, surfaceY - vdWGap);
                            layerGradient.addColorStop(0, 'rgba(140, 140, 145, 0.7)');
                            layerGradient.addColorStop(0.5, 'rgba(160, 160, 165, 0.8)');
                            layerGradient.addColorStop(1, 'rgba(120, 120, 130, 0.75)');
                            ctx.fillStyle = layerGradient;
                            ctx.fill();
                            
                            ctx.strokeStyle = 'rgba(80, 80, 90, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            for (let i = 0; i <= layerSamples; i++) {
                                const x = layerStartX + (i / layerSamples) * layerWidth;
                                const phase = k * x - omega * t;
                                const surfaceDisplacement = sawActive ? -amplitude * spacingY * 0.35 * Math.cos(phase) : 0;
                                const y = surfaceY + surfaceDisplacement - vdWGap;
                                
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            ctx.stroke();
                        }
                    }
                    
                    // Draw atoms
                    for (let iy = 0; iy < nY; iy++) {
                        for (let ix = 0; ix < nX; ix++) {
                            const atom = atoms[iy][ix];
                            const atomRadius = Math.max(3, baseSpacing * 0.2);
                            
                            let baseColor = { r: 120, g: 120, b: 130 };
                            
                            if (showStrain && sawActive) {
                                const strain = amplitude * Math.cos(atom.phase) * atom.decayFactor;
                                
                                if (strain > 0) {
                                    const intensity = Math.min(1, strain * 2);
                                    baseColor = {
                                        r: 120 + Math.floor(135 * intensity),
                                        g: 120 - Math.floor(70 * intensity),
                                        b: 130 - Math.floor(80 * intensity)
                                    };
                                } else {
                                    const intensity = Math.min(1, -strain * 2);
                                    baseColor = {
                                        r: 120 - Math.floor(70 * intensity),
                                        g: 120 - Math.floor(30 * intensity),
                                        b: 130 + Math.floor(125 * intensity)
                                    };
                                }
                            }
                            
                            const atomGradient = ctx.createRadialGradient(
                                atom.x - atomRadius * 0.3, 
                                atom.y - atomRadius * 0.3, 
                                0, 
                                atom.x, 
                                atom.y, 
                                atomRadius
                            );
                            
                            atomGradient.addColorStop(0, `rgb(${baseColor.r + 40}, ${baseColor.g + 40}, ${baseColor.b + 40})`);
                            atomGradient.addColorStop(0.7, `rgb(${baseColor.r}, ${baseColor.g}, ${baseColor.b})`);
                            atomGradient.addColorStop(1, `rgb(${baseColor.r - 30}, ${baseColor.g - 30}, ${baseColor.b - 30})`);
                            
                            ctx.fillStyle = atomGradient;
                            ctx.beginPath();
                            ctx.arc(atom.x, atom.y, atomRadius, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.4 * atom.decayFactor})`;
                            ctx.beginPath();
                            ctx.arc(atom.x - atomRadius * 0.35, atom.y - atomRadius * 0.35, atomRadius * 0.3, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            ctx.strokeStyle = 'rgba(80, 80, 90, 0.3)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(atom.x, atom.y, atomRadius, 0, 2 * Math.PI);
                            ctx.stroke();
                        }
                    }
                    
                    animationRef.current = requestAnimationFrame(animate);
                };
                
                animate();
                
                return () => {
                    window.removeEventListener('resize', updateCanvasSize);
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [showStrain, showField, showVdWLayer, sawActive]);

            return (
                <div className="w-full h-screen bg-gray-50 flex flex-col">
                    <div className="bg-white border-b border-gray-200 p-4 sm:p-6 shadow-sm">
                        <h1 className="text-xl sm:text-2xl md:text-3xl font-bold text-gray-800 mb-1 text-center">
                            Rayleigh Surface Acoustic Wave
                        </h1>
                        <p className="text-xs sm:text-sm text-gray-500 text-center mb-4 italic">
                            Considerably more complex in reality than in this artistic representation
                        </p>
                        
                        <div className="max-w-3xl mx-auto flex flex-wrap justify-center gap-2">
                            <button
                                onClick={() => setSawActive(!sawActive)}
                                className={`px-3 sm:px-4 py-2 rounded-lg font-semibold text-xs sm:text-sm transition-all ${
                                    sawActive 
                                        ? 'bg-gradient-to-r from-green-500 to-green-600 text-white shadow-lg' 
                                        : 'bg-gradient-to-r from-red-500 to-red-600 text-white shadow-lg'
                                }`}
                            >
                                SAW {sawActive ? 'ON' : 'OFF'}
                            </button>
                            
                            <button
                                onClick={() => setShowStrain(!showStrain)}
                                className={`px-3 sm:px-4 py-2 rounded-lg font-semibold text-xs sm:text-sm transition-all ${
                                    showStrain 
                                        ? 'bg-gradient-to-r from-blue-500 to-red-500 text-white shadow-lg' 
                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                }`}
                            >
                                {showStrain ? 'Hide' : 'Show'} Strain
                            </button>
                            
                            <button
                                onClick={() => setShowField(!showField)}
                                className={`px-3 sm:px-4 py-2 rounded-lg font-semibold text-xs sm:text-sm transition-all ${
                                    showField 
                                        ? 'bg-gradient-to-r from-cyan-500 to-yellow-500 text-white shadow-lg' 
                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                }`}
                            >
                                {showField ? 'Hide' : 'Show'} Piezo Field
                            </button>
                            
                            <button
                                onClick={() => setShowVdWLayer(!showVdWLayer)}
                                className={`px-3 sm:px-4 py-2 rounded-lg font-semibold text-xs sm:text-sm transition-all ${
                                    showVdWLayer 
                                        ? 'bg-gradient-to-r from-blue-400 to-blue-600 text-white shadow-lg' 
                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                }`}
                            >
                                {showVdWLayer ? 'Hide' : 'Show'} vdW Layer
                            </button>
                        </div>
                        
                        <div className="mt-3 h-6 flex flex-wrap justify-center gap-4 text-xs sm:text-sm text-gray-600">
                            {showStrain && (
                                <>
                                    <span className="flex items-center gap-2">
                                        <span className="w-3 h-3 rounded-full bg-blue-500"></span>
                                        Compression
                                    </span>
                                    <span className="flex items-center gap-2">
                                        <span className="w-3 h-3 rounded-full bg-red-500"></span>
                                        Tension
                                    </span>
                                </>
                            )}
                        </div>
                    </div>
                    <div ref={containerRef} className="flex-1 overflow-hidden">
                        <canvas 
                            ref={canvasRef}
                            className="w-full h-full"
                        />
                    </div>
                </div>
            );
        };

        ReactDOM.render(<SAWVisualization />, document.getElementById('root'));
    </script>
</body>
</html>

